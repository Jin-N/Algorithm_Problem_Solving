[문제링크](https://programmers.co.kr/learn/courses/30/lessons/17685)

2020년도 "가사검색" 문제의 강화 버전같다. 이분탐색과 더불어, 재귀에도 능숙해야 한다.

입력의 크기가 매우 크므로, 어떻게든 O(n*logn)에 해결해야된다는 것은 처음부터 알았다.

문제는, 단순히 일치하는 범위만 찾는 문제라면 한 단어당 logn에 비례하는 시간이 걸리지만, 이 문제의 경우 그 범위의 크기가 1이 될 때까지 계속 재귀적 호출을 해야한다는 점. 따라서 "단어의 평균적 길이"까지 곱한 값이 시간복잡도가 되고, 이러면 실행시간이 터진다.

나는 여기서 살짝 기교를 부려서 재귀실행을 할 때마다 검색해야될 범위를 좁혀나갔고, 시간복잡도는 O(nlogn)에 안착했다. 그럼에도 불구하고 내가 지금까지 풀었던 문제 중에서 실행시간이 가장 아슬아슬했다.



#### 다른 방식

이진 검색트리로 만들어야되나 고민해보았지만 이 문제는 이진 트리와는 무관하다는 것을 깨닫기까지 시간을 소모했다. 그러나 트라이 자료구조는 적합하다. `현재 노드`를 루트로 하는 서브트리에 저장된 단어가 딱 1개이거나, `현재 노드` 자체가 찾고자 하는 단어와 일치한다면 그 때의 `rank`를 반환하는 식으로 풀 수 있다.



#### 소감

이렇게 꽤 세밀하게 검토하고 코딩하기 시작했는데도 30분 안에 끝낼 수 있었다. 큰그림을 먼저 신중하게 그리는 것이 중요하다는 것을 "긍정적인 측면에서" 처음 경험했다. 물론 지난번에 이분탐색을 확실하게 익혀둔 덕택이기도 하다. 디버깅을 거의 하지 않고 끝냈다.



### 정답

```python
def solution(words):
    '''적어도 2개의 단어가 있으므로, 최소한 1문자는 입력해야 한다.'''
    words.sort()
    N = len(words)
    
    def find_rank(word, first, last, length):
        '''단어는 무엇?, 검색할 처음과 마지막은 어디인가?, 어느 길이까지 잘라 검사할 것인가?'''
        if len(word) == length: return length  				# 끝까지 갔다면, 후보가 여럿 남았어도 종료 가능.
        start = first
        end = last
        while start <= end:
            mid = (start + end)//2
            if word[:length] <= words[mid][:length]:
                end = mid - 1
            else:
                start = mid + 1
        lower = start
        
        end = last
        while start <= end:
            mid = (start + end)//2
            if word[:length] < words[mid][:length]:
                end = mid - 1
            else:
                start = mid + 1
        upper = end
        if lower == upper: return length                    #현재 친 부분까지 일치하는 단어가 유일할 때 반환한다.
        return find_rank(word, lower, upper, length + 1)    #범위를 좁히고, 검사할 문자를 1개 늘려 다시 실행
        
    ans = 0
    for word in words:
        ans += find_rank(word, 0, N-1, 1)
    return ans
```

