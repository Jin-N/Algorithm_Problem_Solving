[문제링크](https://programmers.co.kr/learn/courses/30/lessons/67259)











### 정답(DP)

```python
delta = [ [1, 0], [0, 1], [-1, 0], [0, -1] ]

def solution(board):
    size = len(board)
    arr = [[1]*(size+2)]                            # arr은 마진이 추가된 board
    arr += [ [1] + row + [1] for row in board ]
    arr.append([1]*(size+2))
    del board
    
    visit = [ [[0]*4 for _ in range(size+2)] for _2 in range(size+2) ]
    # 0, 1, 2, 3 은 차례대로 6시, 3시, 12시, 9시 방향을 의미한다.
    # visit[1][1][3]은 좌표 (1, 1)에서 9시를 바라보는 상태
    
    ans = []                   # i번째 인덱스의 원소는 100*i의 금액으로 도달할 수 있는 상태들의 집합이다.
    ans.append({ (1, 1, i) for i in range(4) })         # 비용이 0인 경우부터 체크 
    for i in range(4):
        visit[1][1][i] = 1
            
    # (size, size)가 발견될 때까지 계속 더해나간다.
    for i in range(1, 1<<30):
        temp = set()
        for status in ans[i-1]:     # 직진하는 경우
            dx, dy = delta[status[2]]
            x, y, di = status[0]+dx, status[1]+dy, status[2]
            if visit[x][y][di]: continue
            if arr[x][y]: continue
            visit[x][y][di] = 1
            temp.add((x, y, di))
        
        if i >= 6: 
            for status in ans[i-6]:                         # 코너링하는 경우
                for di in range(4):
                    if not (di-status[2])%2: continue       # 직진과 후진은 제외
                    dx, dy = delta[di]
                    x, y = status[0]+dx, status[1]+dy
                    if visit[x][y][di]: continue
                    if arr[x][y]: continue
                    visit[x][y][di] = 1
                    temp.add((x, y, di))
                         
        if (size, size, 0) in temp or (size, size, 1) in temp: break        # 도착했다면 탈출
        ans.append(temp)
        
    return 100*i
```



### 정답(다익스트라)

```python

```

