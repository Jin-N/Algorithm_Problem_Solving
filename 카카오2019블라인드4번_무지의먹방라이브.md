[문제링크](https://programmers.co.kr/learn/courses/30/lessons/42891)



효율성과 정확성을 따로 채점하는 특이한 문제다.

가장 먼저 원형 큐를 만들어서 시뮬레이션하는 방법을 생각해볼 수 있으나, 이렇게 풀면 큰 사이즈의 테스트케이스를 감당하지 못한다.

어떤 접시가 비워질 때마다 몇 주차를 돌았고, 그 주차마다 몇개의 접시를 돌아야되는지 블록으로 묶어서 계산해야 주어진 시간 안에 풀 수 있다. 처음부터 이렇게 했으나, 해당 주차들을 돌 때마다 info를 수정했더니 실패했다. 이유는 시간복잡도가 O(n^2)이 나왔기 때문. 
수정하지 않고 참조만 하는 식으로 코드를 변경하고나서야 비로소 모든 테스트케이스를 통과할 수 있었다.

이 때의 시간복잡도는 sort가 결정한다(O(nlogn)). 만약 접시에 담긴 음식의 양이 작았다면 counting sort를 쓰는 것이 더 빨랐을 것이고 문제의 시간복잡도도 O(n)으로 줄었을 것이다.

문제 자체는 평이했으나, 시험에서 알맞는 시간 내에 풀기에는 아직 좀 더 훈련이 필요함을 느낀다.



### 정답

```python
def solution(food_times, k):
    if sum(food_times) <= k: return -1
    info = food_times[:]
    info.sort(reverse = True)
    
    trans = []      # 각 요소는 (돌아야 되는 주차, 해당 접시 갯수)를 의미한다.
    cycle = 0
    for i in range(len(food_times)-1, -1, -1):
        if cycle == info[i]: continue
        cycle = info[i]
        trans.append([info[i], i+1])
        
    for i in range(len(trans)-2, -1, -1):
        trans[i+1][0] -= trans[i][0]
        
    #이제 trans를 돌며 k를 최대한 줄인다. cycle 횟수도 저장
    cycle = 0
    for i in range(len(trans)):
        temp = trans[i][0]*trans[i][1]
        if temp > k: break
        k -= temp
        cycle += trans[i][0]
        
    a, k = divmod(k, trans[i][1])
    cycle += a
    
    # 원본을 돌며, cycle보다 큰 것만 센다.
    for i in range(len(food_times)):
        if food_times[i] <= cycle: continue
        if k == 0: break
        k -= 1
        
    return i+1
```

