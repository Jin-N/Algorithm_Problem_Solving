```python
info = [
    # 5*3의 패턴을 검사한다. 2, 3, 5, 6, 8만 지울 수 있다.
    # 빨강
    '000000111001000', '000000110100100', '000000100111000', '010010110000000',
    # 주황
    '000000111100000', '000000100100110', '000001111000000', '000000110010010',
    # 파랑
    '000010111000000', '000000100110100', '000000111010000', '000010110010000',
]

from collections import deque
def solution(board):
    '''보드에 마진을 붙인다. 좌, 우, 하 2개씩. (블록번호, 타입번호)'''
    N = len(board)
    Board = [ [[0, 12] for _ in range(N + 4)] for __ in range(N + 2) ]
    for i in range(N):
        for j in range(N):
            Board[i][j + 2][0] = board[i][j]
    del board

    '''각 열마다 블록의 순서를 deque으로 저장한다.'''
    lookdown = [deque() for _ in range(N + 4)]
    for j in range(2, N + 2):
        cur = 0
        for i in range(N):
            if Board[i][j][0] == 0: continue
            if Board[i][j][0] == cur: continue
            cur = Board[i][j][0]
            lookdown[j].append(cur)

    '''Board에서 각 블록의 타입을 알아내어 저장한다.'''
    for j in range(2, N + 2):
        for i in range(N):
            num, TYPE = Board[i][j]
            if num == 0: continue           # 블록이 아니면 스킵
            if TYPE != 12: continue         # 타입 라벨링이 이미 끝났으면 스킵
            pattern = ''
            for I in range(i - 2, i + 3):
                for J in range(j, j + 3):
                    if Board[I][J][0] == num:
                        pattern += '1'
                    else:
                        pattern += '0'
            pattern = info.index(pattern)
            for I in range(i - 2, i + 3):
                for J in range(j, j + 3):
                    if Board[I][J][0] == num:
                        Board[I][J][1] = pattern

    '''각 열마다 꼭대기를 저장한다.'''
    top = [0] * (N + 4)
    for j in range(N + 4):
        for i in range(N + 1):
            if Board[i][j][0] != 0: break
        top[j] = i                          # N이면 열이 비었다는 것을 나타낸다.

    '''[채워야 되는 열, 점유한 열]을 반환하는 함수, 반드시 제거 가능한 블록만 들어간다.'''
    def lack(i, j, num, T):
        for J in range(j-2, j+3):       # (I, J) 최고 좌측의 최상단을 의미한다.
            for I in range(i-2, i+3):
                if Board[I][J][0] == num: break
            else: continue
            break
        if T == 2: return [[J+1, J+2], [J, J+1, J+2]]
        if T == 3: return [[J], [J, J+1]]
        if T == 5: return [[J+1], [J, J+1]]
        if T == 6: return [[J, J+1], [J, J+1, J+2]]
        if T == 8: return [[J, J+2], [J, J+1, J+2]]
        
    '''다시 순회하며 빼낸다.'''
    ans = 0
    gate = True
    while gate:
        gate = False  # 단 하나의 열에서라도 삭제 가능하다면 True로 바뀜
        for j in range(2, N + 2):
            if top[j] >= N: continue                                 # 비어있는 열이면 취소
            if Board[top[j]][j][1] not in {2, 3, 5, 6, 8}: continue  # 지울 수 없는 타입이면 취소
            num, T= Board[top[j]][j]
            span = lack(top[j], j, num, T)
            gate2 = True
            for x in span[0]:                                           # 막혀있으면 취소
                if lookdown[x][0] != num:
                    gate2 = False
                    break
            if not gate2: continue
            
            for x in span[1]:               # deque에서 빼낸다.
                lookdown[x].remove(num)
            for i in range(top[j] - 2, top[j] + 3):  # Board에서 지운다.
                for x in range(j-2, j+3):
                    if Board[i][x][0] == num:
                        Board[i][x] = [0, 12]
            for x in range(j-2, j+3):  # top을 갱신한다.
                for i in range(top[x], N + 1):
                    if Board[i][x][0] != 0: break
                top[x] = i
                
            ans += 1
            gate = True
            
    return ans
```

